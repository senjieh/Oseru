<!DOCTYPE html>
<html>
    <head>
        <style>
            body { 
            }
            canvas {
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
            }
            #render-button {
                width: 180px;
                height: 50px;
                font-size: 24pt;
            }
            #the-canvas { border: 1px solid darkblue; }
            #user-matrix input { width: 64px; font-size: 24px; }
        </style>
    </head>


    

    <body>
        <canvas id = "the-canvas" width = "800" height = "600"></canvas>
        <script src = "lib.js"></script>
        <script src = "vector.js"></script>
        <script src = "matrix.js"></script>
        <script src = "normal_mesh.js"></script>
        <script src = "controls.js"></script>
        <script src = "lit_material.js"></script>
        <script src = "light.js"></script>
        <script src = "node_note.js"></script>
        <script src = "scene.js"></script>
        <script src = "menu.js"></script>
        <script src = "../leaderboards/note-score.js"></script>
        <script src = "../leaderboards/final-score-tally.js"></script>
        <script src = "../components/Game.js" type="module"></script>

        <!-- npm stuff !-->
        <!-- <script src = "../../node_modules/tone/build/Tone.js"></script>
        <script src = "../../node_modules/@magenta/music/es6/core.js"></script>
        <script src = "../../node_modules/html-midi-player/dist/midi-player.min.js"></script> !-->


        

        <!-- external stuff !-->
        <script src="https://cdn.jsdelivr.net/combine/npm/tone@14.7.58,npm/@magenta/music@1.23.1/es6/core.js,npm/focus-visible@5,npm/html-midi-player@1.5.0"></script>
        <midi-player
          src="../midi/midifiles/SilentNight.mid"
          sound-font visualizer="#myVisualizer" id="midi_player">
        </midi-player>
        <midi-visualizer type="piano-roll" id="myVisualizer"></midi-visualizer>

        <!--<midi-payer id = 'midi_player' sound-font visualizer="#myVisualizer"></midi-payer>
        <midi-visualizer type="piano-roll" id="myVisualizer"></midi-visualizer> !-->

        <script>
            // server: python3 -m http.server 
            // http://localhost:8000//main.html

            //import 'html-midi-player'

            const canvas = document.getElementById( 'the-canvas' );
            /** @type {WebGLRenderingContext} */
            const gl = canvas.getContext( 'webgl2' );

            let GOURAUD_VERTEX_SHADER = 
            `   #version 300 es
                precision mediump float;

                uniform mat4 projection;
                uniform mat4 modelview;
                uniform mat4 model;
                uniform mat4 view;
                uniform vec3 viewer_loc;

                uniform vec3 sun_dir;
                uniform vec3 sun_color;
                
                uniform vec3 light1_loc;
                uniform vec3 light1_color;

                uniform vec3 light2_loc;
                uniform vec3 light2_color;

                const float light_attenuation_k = 0.01;
                const float light_attenuation_l = 0.1;
                const float light_attenuation_q = 0.00; /* no quadratic term for now */

                uniform float mat_ambient;
                uniform float mat_diffuse;
                uniform float mat_specular;
                uniform float mat_shininess;

                in vec3 coordinates;
                in vec4 color;
                in vec2 uv;
                in vec3 surf_normal;

                out vec4 v_color;
                out vec2 v_uv;

                vec3 diff_color( 
                    vec3 normal, 
                    vec3 light_dir,
                    vec3 light_color, 
                    float mat_diffuse 
                ) {
                    return mat_diffuse * light_color * max( dot( normal, light_dir ), 0.0 );
                }

                vec3 spec_color( 
                    vec3 normal, 
                    vec3 light_dir,
                    vec3 eye_dir, 
                    vec3 light_color, 
                    float mat_specular,
                    float mat_shiniess
                ) {
                    float cos_light_surf_normal = dot( normal, light_dir );

                    if( cos_light_surf_normal <= 0.0 ) {
                        return vec3( 0.0, 0.0, 0.0 );
                    }

                    vec3 light_reflection = 
                        2.0 * cos_light_surf_normal * normal - light_dir;

                    return 
                        pow( 
                            max( dot( light_reflection, normalize( eye_dir ) ), 0.0  ),
                            mat_shininess 
                        ) * light_color * mat_specular;
                }

                float attenuation( vec3 vector_to_light ) {
                    float light1_dist = length( vector_to_light );
                    float light1_atten = 1.0 / ( 
                        light_attenuation_k + 
                        light_attenuation_l * light1_dist +
                        light_attenuation_q * light1_dist * light1_dist
                    );

                    return light1_atten;
                }

                void main( void ) {
                    vec3 normal_tx = normalize( mat3( model ) * surf_normal );
                    vec3 coords_tx = ( model * vec4( coordinates, 1.0 ) ).xyz;

                    gl_Position = projection * modelview * vec4( coordinates, 1.0 );
                    vec3 eye_dir = normalize( viewer_loc - coords_tx );

                    vec4 ambient_color = vec4( mat_ambient, mat_ambient, mat_ambient, 1.0 );

                    // vec3 sun_dir_tx = 
                    float cos_sun_dir_surf_normal = dot( sun_dir, normal_tx );
                    vec3 sun_diffuse_color = diff_color( normal_tx, sun_dir, sun_color, mat_diffuse );
                    
                    vec3 sun_spec_color =
                        spec_color( normal_tx, sun_dir, eye_dir, sun_color, mat_specular, mat_shininess );

                    vec4 color_from_sun = vec4( sun_diffuse_color + sun_spec_color, 1.0 );

                    vec3 vector_to_light1 = light1_loc - coords_tx;
                    vec3 light1_dir = normalize( vector_to_light1 );
                    float light1_atten = attenuation( vector_to_light1 );

                    vec3 vector_to_light2 = light2_loc - coords_tx;
                    vec3 light2_dir = normalize( vector_to_light2 );
                    float light2_atten = attenuation( vector_to_light2 );
                
                    vec3 light1_diffuse_color = diff_color( 
                        normal_tx, light1_dir, light1_color, mat_diffuse);
                    vec3 light1_spec_color = spec_color( 
                        normal_tx, light1_dir, eye_dir, light1_color, mat_specular, mat_shininess );
                    vec4 color_from_light1 = vec4(
                            ( light1_diffuse_color + light1_spec_color ) * light1_atten, 1.0 );

                    vec3 light2_diffuse_color = diff_color( 
                        normal_tx, light2_dir, light2_color, mat_diffuse);
                    vec3 light2_spec_color = spec_color( 
                        normal_tx, light2_dir, eye_dir, light2_color, mat_specular, mat_shininess );
                    vec4 color_from_light2 = vec4(
                            ( light2_diffuse_color + light2_spec_color ) * light2_atten, 1.0 );

                    /* multiply color by 0 to remove it. try changing the 0 to a small number like .2
                    and the 1 to the complement of that number (1 - .2 = .8) to see how color blending works.*/
                    v_color = 
                        ( 0.0 * color ) + 
                        ( 1.0 * (
                            ambient_color +
                            color_from_sun +
                            color_from_light1 +
                            color_from_light2
                        ) );
                    v_uv = uv;
                }
            `;

            let GOURAUD_FRAGMENT_SHADER = 
            `   #version 300 es
                precision mediump float;

                in vec4 v_color;
                in vec2 v_uv;

                out vec4 f_color;

                uniform sampler2D tex_0;

                void main( void ) {
                    f_color = v_color * texture( tex_0, v_uv ); 

                    /* we can test depth values with this.
                    f_color = vec4(vec3(gl_FragCoord.z), 1.0); */
                }
            `;
            let vert_shader_loaded = false;
            let vert_req = load_txt_file('vertex.vs', function() {
                console.log('loaded vertex.vs');
                GOURAUD_VERTEX_SHADER = vert_req.responseTest;
                vert_shader_loaded = true;
                //TODO: should block render loop until loaded
            });

            let frag_shader_loaded = false;
            let frag_req = load_txt_file('fragment.fs', function() {
                console.log('loaded fragment.fs');
                GOURAUD_FRAGMENT_SHADER = vert_req.responseTest;
                frag_shader_loaded = true;
            });

            // TODO: block needs to happen before getting to page


//----------------------------------------------------------------------------------------------------
//           DEBUG VARIABLES
//----------------------------------------------------------------------------------------------------
            // NOTE: debuging vars
            //DRAW_ASTROIDS = true;
            const DRAW_SKYBOX = true;
            const DRAW_SUN = true;


//----------------------------------------------------------------------------------------------------
//           BASIC SETUP
//----------------------------------------------------------------------------------------------------
            let lit_program = 
                create_compile_and_link_program( 
                    gl, 
                    /*PHONG_VERTEX_SHADER,*/ GOURAUD_VERTEX_SHADER,
                    /*PHONG_FRAGMENT_SHADER,*/ GOURAUD_FRAGMENT_SHADER
                );

            gl.useProgram( lit_program );

            // setup render loop
            set_render_params( gl );


            // lets make a solar system to start
            //let solar_system = new Scene();
            
            // setup controls
            const DESIRED_TICK_RATE = 60;
            const DESIRED_MSPT = 1000.0 / DESIRED_TICK_RATE;

            const ROTATION_SPEED = 0.1; // eighth turn per second
            const ROTATION_SPEED_PER_FRAME = ROTATION_SPEED / DESIRED_TICK_RATE;

            const FLY_SPEED = 10;    // units per second
            const FLY_SPEED_PER_FRAME = FLY_SPEED / DESIRED_TICK_RATE;

            let keys = Keys.start_listening();

            // setup projection matrix
            const FOV_ANGLE = 0.125;
            const ASPECT_RATIO = 4/3;
            let projection = Mat4.perspective_fovx( FOV_ANGLE, ASPECT_RATIO, 0.125, 1024 );
            let current_program = lit_program;

            // global pause variable
            var PAUSE_TIME = 0;

            // dict that tracks aspects of game state
            // 0 = not done, 1 = done, 2 = done, past first setup only code
            var gamestate = {
                "is_paused":0,
                "main_menu":0,
                "json_midi_loaded":0,
                "score_generated":0,
                "score_tracker_generated":0,
                "texture_loaded":0,
                "meshs_loaded":0,
                "background_loaded":0,
                "acvite_note":0,
                "midi_loaded":0,
                "game_start":0,
            }

//----------------------------------------------------------------------------------------------------
//          LOAD RESOURCES
//----------------------------------------------------------------------------------------------------

            // load textures
            /*
            let metal = 
                new LitMaterial( gl, 'tex/metal.png', gl.LINEAR, 0.25, 1, 2, 5 ); */
            const debug_tex = 
                new LitMaterial(gl, null, gl.LINEAR, 0.25, 1, 2, 5);
            const skybox_tex = 
                new LitMaterial(gl, 'tex/2k_stars_milky_way.jpg', gl.LINEAR, 2, 1, 2, 5);
            const target_tex =
                new LitMaterial(gl, 'tex/2k_sun.jpg', gl.LINEAR, 1, 1, 2, 5);
            const note_tex =
                new LitMaterial(gl, 'tex/2k_neptune.jpg', gl.LINEAR, 1, 1, 2, 5);


            // skybox mesh to pass to score
            var skybox = null;
            if (DRAW_SKYBOX){
                skybox = NormalMesh.box(gl, current_program, 1023,1023,1023, skybox_tex);
            } else {
            }
            
//----------------------------------------------------------------------------------------------------
//           SETUP LIGNTS
//----------------------------------------------------------------------------------------------------
            
            let light1 = new Light( -20, -20, 0, 1.0, 0.2, 0.9, 1 );
            let light2 = new Light(20,20,0, 0,1,0, 2);


            /*
            let mesh =
                NormalMesh.uv_sphere( gl, lit_program, 1, 16, scale ); 
                // NormalMesh.box( gl, lit_program, 1, 1, 1, metal ); */


//----------------------------------------------------------------------------------------------------
//           TEST CODE
//----------------------------------------------------------------------------------------------------
            //startPitchDetection()
            test_node = new Node(0,0,10, 0,0,0, 1,1,1, null);
            fetch('obj/test.obj').then((response) => {
                if (response.status == "200") {
                    console.log("fetched data",response);
                    gamestate.json_midi_loaded = 1;
                    return response.text();
                }
                else {
                    console.log("ERROR: ",response.status);
                }
            }).then((response) => {
                text = parse_obj(response);
                console.log(".obj text ",response);
                test_node.data = NormalMesh.from_obj(gl, lit_program, text, note_tex);
                console.log("test mesh ",test_node.data);
            });

            /*let tmp = new Game(null);
            tmp.startPitchDetection().then((response) => {
                console.log(response)
            });*/
            //startPitchDetection();

//----------------------------------------------------------------------------------------------------
//           GENERATE SCENE
//----------------------------------------------------------------------------------------------------
            const midi_file = "../midi/modmidi/SilentNight.mid"
            const player = document.getElementById('midi_player');
            const visuilizer = document.getElementById('myVisualizer');
            //player.src = midi_file;

            // TODO: fetch meshs same way
            var score = null;
            var leaderboard = null;
            var score_json = null;
            var extra_note = new ExtraNote();
            var note_score_lst = [];
            note_score_lst.push(extra_note);
            var end_time = 0;
            var num_expected_noted = 0;
            const file = "jsonMidi/SilentNight.json";
            var final_score = new FinalScore(file);
            // TODO: notes currently timed to top of note reaching bottom of target, not middle-to-middle as should be expected
            fetch(file).then((response) => {
                // get note json
                if (response.status == "200") {
                    console.log("fetched data",response);
                    gamestate.json_midi_loaded = 1;
                    return response.json();
                }
                else {
                    console.log("ERROR: ",response.status);
                }
            }).then((response) => {
                // then make score
                score = new Score(response, 100, note_tex, skybox, target_tex);
                score_json = response;
                tmp = response[response.length-1];
                num_expected_noted = response.length;
                // last note at last note + 10s
                end_time = tmp.time_played * 1000 + 5000;
                //leaderboard = new NoteScore(response, )
                console.log("new score made, set timeout ",score);
                // timeout for game state, game waits load time + 5s to ensure smooth transition
                setTimeout(() => {
                    gamestate.score_generated = 1;
                }, 5000);
                //gamestate.score_generated = 1;
            }).then((response) => {
                let button = new Menu('start_button', 'start_button_content');

                button.open_modal(
                    "Are you ready?",
                    "Press to start!",
                    "Start",
                    "Stop?")
                    .then((value) => {
                        gamestate.game_start = 1;
                        //player.start();
                    }).catch((value) => {
                        console.log("error, refresh page and try again ",value);
                    })
            }).catch((err) => {
                console.log("something went wrong making score ",err);
                // TODO: bounce back to stage select on error here
                gamestate.game_start = 1;
            });

            let note_duration = 0;
            let last_check = 0;


            let root = new Scene();

            // initalize camera
            let cam = root.create_node(
                0,0,0, 0,0,0, 1,1,1);
            root.set_camera_node(cam);
            let skybox_note = cam.create_child_node(0,0,0, 0,0,0, 1,1,1, skybox);

            root.root.children.push(test_node);

            // initalize sun
            //root.set_sun_color(1.0, 0.95, 0.85, 0);
            root.set_sun_color(1.0, 1.0, 1.0, 0);
            root.set_sun_direction(1.0,0.0,0.0);

            // TODO: loading graphic while waiting on load
            
            // Track time
            // tie update freq to fps so if game is chugging calcs happen less often
            // game updates should still occur based on now - prev because we aren't Bertha
            // TODO: start at score load
            let start = -1;
            let last_update = -1;


//----------------------------------------------------------------------------------------------------
//           GET USER INPUTS
//----------------------------------------------------------------------------------------------------


            function get_inputs() {
                if (gamestate.score_generated < 1) { 
                    console.log("score not loaded yet");
                    return;
                } else {
                    // test function to play all notes with spacebar only
                    spawners = score.spawners;
                    let current_note = null;
                    // loop through all active notes, find next one to play
                    for (let spawner of spawners){
                        for (let child of spawner.children) {
                            if (child.data instanceof NodeNote) {
                                if (current_note == null) {
                                    current_note = child;
                                    //console.log(child)  
                                } else {
                                    if (child.data.play_at < current_note.data.play_at && current_note.y < 1.9   ) {
                                        current_note = child;
                                    }
                                }
                            }
                        }
                    }
                    if (gamestate.active_note == 0) {
                        // if note was not active last tick
                        gamestate.active_note = 1;
                        note_duratiopn = 0;
                        last_check = performance.now()
                    } else {
                        // if it was active increment note duration
                        note_duration += performance.now() - last_check;
                        last_check = performance.now()
                    }

                    if (current_note == null) {
                        // no active not was found, was a "miss"
                        //console.log("miss ",current_note)
                        extra_note.Increment();
                    } else {
                            
                        if (current_note.y < 1.88 || current_note.y > 1.9) {
                            // note not on target yet, was a "miss"
                            // NOTE: these values are an estimate, could be refined
                            //console.log("miss ",current_note)
                            //current_note.add_yaw(0.05);
                            extra_note.Increment();
                            //console.log(" no active note")
                        } else if (current_note.data.played == true) {
                            // don't double play notes
                            //console.log("note already played", current_note)
                            return;
                        } else {
                            // valid note at correct time, set note as played
                            current_note.data.played = true;
                            // darken played note
                            //current_note.data.mesh.material.ambient /= 2;
                            current_note.add_yaw(0.5);
                            console.log("hit ", current_note);
                            tmp = score_json.pop();
                            // start global timer declared in main loop
                            freq_list = null; // TODO: this needs to get input from mic
                            note_score = new NoteScore(tmp, start, freq_list);
                            note_score_lst.push(note_score);
                            // dummy duration value until actual duration can be properly calculated
                            // TODO: this check notes in order, dose not account for skipped notes
                            final_score.AddNoteScoreToArray(start, freq_list, 100, tmp); 
                        }
                    }
                }
            }

            
//----------------------------------------------------------------------------------------------------
//           RENDER LOOP
//----------------------------------------------------------------------------------------------------
            function render( now ) {
                // window not visible
                //console.log(document.hidden)
                // TODO: tabbing away causes no animation update until tabbed back, then everything happens all at once, should pause until user tabs back
                if (document.hidden) {
                    // current doesn't work
                    PAUSE_TIME += now - last_update;
                    return;
                }
                if (gamestate.is_paused) {
                    // TODO: don't update timer when paused
                    return;
                }

                //console.log(now - last_update)
                last_update = now - PAUSE_TIME + 13000; // hard coded value because test song as 13s lead in
                //last_update *= 10;
                //console.log(now);

                // get permission to draw frame from browser
                requestAnimationFrame( render );
                
                // clear last frame
                gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

                // transform viewer coordinates
                // let viewer_loc = cam.get_transformed_coordinates();
                set_uniform_vec3( gl, current_program, 'viewer_loc', cam.x, cam.y, cam.z );

                // bind lights
                //sun.bind( gl, current_program, modelview );
                //light1.bind( gl, current_program, modelview );
                root.bind_sun(gl, current_program)

                // generate list of meshes to draw
                let mesh_list = [];
                let light_list = []
                //console.log(last_update)
                root.generate_render_batch(mesh_list, light_list, last_update);
                //console.log(Math.floor(last_update/100));

                // TODO: this is a stop gap as currently shader only accepts two hard-ocded dynamic lights
                //light_list[0].bind(gl, current_program);

                //back_end_render(gl, mesh_list);
                let view = root.get_camera_view();

                set_uniform_matrix4( gl, current_program, 'projection', projection.data );
                set_uniform_matrix4( gl, current_program, 'view', view.data );

                // draw meshes in scene
                for (let i=0; i<mesh_list.length;i++) {


                    let mat = mesh_list[i].matrix;
                    let mesh = mesh_list[i].mesh;

                    let model = mat;
                    let modelview = view.mul(model);

                    // apply perspective to mesh
                    set_uniform_matrix4( gl, current_program, 'modelview', modelview.data );
                    set_uniform_matrix4( gl, current_program, 'model', model.data );

                    // apply lights to object
                    light1.bind( gl, current_program, modelview );
                    light2.bind(gl, current_program, modelview);

                    // draw mesh
                    mesh.render(gl);
                } 
            }

//----------------------------------------------------------------------------------------------------
//           DEFINE CONTROLS TODO: move to file maybe?
//----------------------------------------------------------------------------------------------------
            const KEYMAP = {
                //'Space': function() { cam.move_in_direction( 0, 0, FLY_SPEED_PER_FRAME ); },
                'KeyC': function() { cam.move_in_direction( 0, 0, -FLY_SPEED_PER_FRAME ); },
                'KeyA': function() { cam.move_in_direction( -FLY_SPEED_PER_FRAME, 0, 0 ); },
                'KeyD': function() { cam.move_in_direction( FLY_SPEED_PER_FRAME, 0, 0 ); },
                'KeyW': function() { cam.translate( 0, FLY_SPEED_PER_FRAME, 0 ); },
                'KeyS': function() { cam.translate( 0, -FLY_SPEED_PER_FRAME, 0 ); },
                'KeyQ': function() { cam.add_roll( -ROTATION_SPEED_PER_FRAME ); },
                'KeyE': function() { cam.add_roll( ROTATION_SPEED_PER_FRAME ); },
                'ArrowLeft': function() { cam.add_yaw( -ROTATION_SPEED_PER_FRAME ); },
                'ArrowRight': function() { cam.add_yaw( ROTATION_SPEED_PER_FRAME ); },
                'ArrowUp': function() { cam.add_pitch( -ROTATION_SPEED_PER_FRAME ); },
                'ArrowDown': function() { cam.add_pitch( ROTATION_SPEED_PER_FRAME ); },
                'Space': function() {get_inputs();},
            };

//----------------------------------------------------------------------------------------------------
//           UPDATE LOOP
//----------------------------------------------------------------------------------------------------
            function update() {
                let keys_down = keys.keys_down_list();

                if (gamestate.is_paused) {
                    return;
                }

                if (gamestate.game_start == 1) {
                    // start countown for song
                    gamestate.game_start = 2;
                    // 5 sec timer to game start, easier then counting time in render loop
                    setTimeout(() => {
                        gamestate.game_start = 3;
                        player.start();
                        }, 3000);
                    //gamestate.game_start = 3;

                } else if (gamestate.game_start == 2) {
                    // in countdown

                }
                if (gamestate.game_start == 3) {
                    // score has loaded, change from loading screen to song in ready state
                    gamestate.score_generated = 2;
                    root = score.root;
                    cam = score.cam;

                    // TODO: make this part of score generation process
                    root.set_sun_color(1.0, 1.0, 1.0, 0);
                    root.set_sun_direction(1.0,0.0,0.0);
                    console.log("root: ",root);

                    //skybox = cam.create_child_node(0,0,0, 0,0,0, 1,1,1, skybox );
                    gamestate.game_start = 4;
                    start = performance.now()
                } else if (gamestate.score_generated == 1){
                    // game loaded, change display animation
                    gamestate.score_generated +=1;
                } else if (gamestate.score_generated < 1) {
                    // display loading screen
                }

                // check for end of game
                if (gamestate.game_start >= 4 && (performance.now() - start) > end_time) {
                    // call end of game
                    gamestate.score_generated = 3;
                    const score = final_score.CalculateFinalScore(extra_note);
                    console.log("song over ",score);
                    // TODO: call redirect and pass score
                }

                // update clock if game started
                if (gamestate.score_generated > 0) {
                    last_update = performance.now() - start
                    //console.log(last_update);
                }

                for( const key of keys_down ) {
                   let bound_function = KEYMAP[ key ];

                   if( bound_function ) {
                       bound_function();
                   }
                }

                //--------------------------------------------------------------------------
                // Passive Movement
                //--------------------------------------------------------------------------
                // skybox follow cam
                /*if (DRAW_SKYBOX) {
                    score.skybox.x = cam.x;
                    score.skybox.y = cam.y;
                    score.skybox.z = cam.z;
                }*/

                // hardcoded lights
                // TODO: light as child node
                light1.x=cam.x;
                light1.y=cam.y;
                light1.z=cam.z+50;



                //--------------------------------------------------------------------------
                // Game State Logic
                //--------------------------------------------------------------------------

                //--------------------------------------------------------------------------
                // Debug stuff
                //--------------------------------------------------------------------------

                
                return;
            }
            
            // ask browser for frame
            requestAnimationFrame( render );
            // set game speed
            setInterval( update, DESIRED_MSPT );
        </script>
    </body>
</html>