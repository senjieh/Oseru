const {NodeNote, NoteSpawner, Score} = require("./node_note.js");
const {Node, Scene, RenderMesh, RenderLight} = require("./scene.js");

//const html = 

//let canvas = document.getElementById('the-canvas');
//let gl = canvas.getContext('webgl2');
// filler vars not needed in test
const gl = null;
const program = null;
const tex = null;

let root = new Scene();

beforeEach(() => {
	root = new Scene();
	let cam = root.create_node(0,0,0, 0,0,0, 1,1,1);
	root.set_camera_node(cam);
	//cam.create_child_node(0,0,0, 0,0,0, 1,1,1, null);
});

/*let test_score = new Score(gl, program, note_data, 100);

test("Calc target position relative to camera", () => {
	let spawner_node = cam.create_child_node(0,0,0, 0,0,0, 1,1,1, null);
	let test_spawner = new NoteSpawner(null, null, null, test_node);
	test_node.data = test_spawner;
	expect(test_spawner.get_target_height(0, 1)).toBe();
});*/
const FOV_GAMLE = 0.125;
const ASPECT_RATIO = 4/3;

function make_list_of_spawners(num_spawners) {
	

	// calc frustum edge
    let distance = 3;	// this is arbitrary, can be any number grater then min cam distance
    let edge_distance = Math.tan(Math.PI * FOV_ANGLE) * distance;
    // calc note width
    let num_notes = num_spawners;
    let padding_pre = 0.05;
    let div_width = (2*edge_distance)/num_notes;
    let padding = div_width * padding_pre;
    let width = div_width - padding;
    // calc height
    let height = width/3;
    let bottom = -edge_distance * (1/ASPECT_RATIO) + height/2 + padding;

    let spawners = [];

    for (let i=0; i<spawners.length; i++) {
    	// no mesh for spawners because test
        let tmp_node = spawners[i].create_child_node(0,0,0, 0,0.25,0, 1,1,1, null);
        let top = spawners[i].data.get_target_height(padding, height);
        tmp_node.warp(tmp_node.x, top, tmp_node.z);
    }

    return spawners;
}

test("Spawner generates properly", () => {
	let spawners = make_list_of_spawners(1);

	// make spawnser nodes children of cam
	for (let i=0; i<spawners.length; i++) {
		cam.children.push(spawners[i]);
	}

	// TODO: redundant in current form
	// calc dimensions of note
	const distance = 3;
	const edge_distance = Math.tan(Math.PI*FOV_ANGLE) * distance;	// distance from center to side of plane
	const num_notes = 1;
	const padding_pre = 0.05;
	// calc note mesh size
	const div_width = (2*edge_distance)/num_notes;
	const width = div_width - padding;
	const height = width/3;
	// calc position of mesh
    const padding = div_width * padding_pre;
    const top = edge_distance * (1/ASPECT_RATIO);
    const bottom = -top;

	// check position of spawner
	// with one note should be centered on screen
	expect(spawners[0].x).toBe(0);
	expect(spawners[0].y).toBe(bottom + padding + height/2);
	// default distance is 3
	expect(spawners[0].z).toBe(3);

	// check scale of spawners with 1 node
	expect(spawners[0].s_x).toBe(spawners[0].s_y * 3);	// proper ration of one-beat note
	// TODO: should scale in node, not in mesh size
	expect(spawners[0].s_x).toBe(1);
	expect(spawners[0].s_y).toBe(1);
	expect(spawners[0].s_z).toBe(1);

	// check rotation of spawner
	expect(spawners[0].roll).toBe(0);
	// TODO: generate notes without minimizing rotation
	// current config makes a xy platform then rotates it failing this test
	expect(spawners[0].pitch).toBe(0);	
	expect(spawners[0].yaw).toBe(0)

	// check position of target
	// height should be edge distance - padding
	expect(spawners[0].get_target_height()).toBe(top - padding - height/2)

	// compare target and note mesh
});

test("Spanwer note generation", () => {
	// make dummy data

	// spawn note at correct time

	// generates note mesh

	// test bad note

	// only spawn one note per tic (even if same timing)

	// old notes removed from list

	// passed node removed from subnodes once off screen

	// check long notes
});

test ("NodeNote object generated by spawner", () => {
	// contains correct data

	// contains correct mesh if note

	// contains correct mesh if mine

	// colored properly based on timing
})

test("Spawner mine generation", () => {
	// make dummy data

	// notes and mines different mesh
});